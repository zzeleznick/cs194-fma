---
layout: post
title: Face Morphing
subtitle: Warping, Averaging, and Caricatures
images: site.images
---


h2(anchor#main). %(octicon octicon-link)I. Introduction%


<notextile>
Here, we will explore the beauty of determining facial features, triangulation, and morphing in great detail. Shape and symmetry of individual faces enable us to distinguish identities, and we will see how to morph someone’s face into someone else's face, compute the average face of a population, and extrapolate from a population mean to create a caricature.
</notextile>

<h4> Brief Overview of Key Challenges </h4>

1) Mapping correspondence of features between faces

2) Determining the affine transformation matrix to warp one face to another

3) Ensuring consistency between feature space labeling and dimensions


<h2>  II. Defining Correspondences </h2>
<notextile>
Distinctive features such as eyes and eyebrows, lips and nose, ears and chin, are important to preserve — and act as the key areas of interest to morph between faces. In this project, I used the
</notextile> <code> ginput </code> function from <code> matplotlib.pyplot</code>. <notextile>
I then selected n points [30-40] for faces A,B, selecting each pair of corresponding point side-by-side.
</notextile>

<h3> Triangulation Here....[1] </h3>

<h2 class="center"> III. Face Morphs </h2>


<div class="pure-g">
{% for image in site.p5_morphs offset:0%}
    <div class="pure-u-1-3 pure-u-md-1-3 center"> !{{ site.github_path | escape  }}{{site.p5_path}}{{image.ref}}({{image.title}})!:http://zzeleznick.github.io/cs194-fma/{{site.p5_path}}{{image.ref}}
         {{image.title}}
       <br><br>
    </div>
{% endfor %}
</div>
<notextile></notextile>


{% comment %}
<div class="pure-g">
{% for image in site.p4_alg offset:0%}
    <div class="pure-u-1-3 pure-u-md-1-2 center"> !{{ site.github_path | escape  }}{{site.p4_path}}{{image.ref}}({{image.title}})!:http://zzeleznick.github.io/cs194-fma/{{site.p4_path}}{{image.ref}}

         {% if image.ref == 'alg/DP2.png' %}  {{image.title}}[2]
         {% elsif image.ref == 'alg/DP3.png' %} {{image.title}}[3]
         {% elsif image.ref == 'alg/DP5.png' %} {{image.title}}[4]
         {% else %} {{image.title}} {% endif %}
       <br><br>
    </div>
{% endfor %}
</div>
<notextile>
    For a closer look at the implementation details, check out the <a target="_blank" href= {{ site.github_path | escape  }}{{site.p4_docs}}>README </a>
    for my package.
</notextile> <br><br>
{% endcomment %}


<!--script src="https://gist.github.com/zzeleznick/bfb5a0c9c3a53d0bfdd6.js"></script-->


<h2 class="center"> IV. Average Faces </h2>

<div class="pure-g">
{% for image in site.p5_ave offset:0%}
    <div class="pure-u-1-4 pure-u-md-1-2 center"> !{{ site.github_path | escape  }}{{site.p5_path}}{{image.ref}}({{image.title}})!:http://zzeleznick.github.io/cs194-fma/{{site.p5_path}}{{image.ref}}
         {{image.title}}
       <br><br>
    </div>
{% endfor %}
</div>
<notextile>
For each of the input images above, each pair of faces was morphed to the midway shape and then cross disolved to simulate the average of the two faces.
</notextile> <br> <br>

<h2 class="center"> V. Population Average Faces </h2>

<div class="pure-g">
{% for image in site.p5_popAve limit:3 offset:0%}
    <div class="pure-u-1-3 pure-u-md-1-3 center"> !{{ site.github_path | escape  }}{{site.p5_path}}{{image.ref}}({{image.title}})!:http://zzeleznick.github.io/cs194-fma/{{site.p5_path}}{{image.ref}}
         {{image.title}}
       <br><br>
    </div>
{% endfor %}
</div>

<div class="pure-g">
{% for image in site.p5_popAve offset:3%}
    <div class="pure-u-1-4 pure-u-md-1-2 center"> !{{ site.github_path | escape  }}{{site.p5_path}}{{image.ref}}({{image.title}})!:http://zzeleznick.github.io/cs194-fma/{{site.p5_path}}{{image.ref}}
         {{image.title}}
       <br><br>
    </div>
{% endfor %}
</div>


<h3 class='center'> IX. Failure Cases </h3>


<notextile>
Faces are really tough to scale down properly, especially when they fill the frame of the image.
Standard rescaling would be more appropriate in this case.
</notextile>

<div class="videoWrapper">
    <!-- Copy & Pasted from YouTube -->
    <iframe width="560" height="349" src="http://vimeo.com/143365166" frameborder="0" allowfullscreen></iframe>
</div>

<object width="WIDTH" height="HEIGHT">
 <param name="allowfullscreen" value="true" />
 <param name="allowscriptaccess" value="always" />
 <param name="movie" value="https://vimeo.com/143365166&amp;server=vimeo.com&amp;autoplay=1&amp;loop=1&amp;fullscreen=1" />
 <embed src="https://vimeo.com/143365166&amp;server=vimeo.com&amp;autoplay=1&amp;loop=1&amp;fullscreen=1" allowfullscreen="true" allowscriptaccess="always" width="WIDTH" height="HEIGHT"></embed>
 </object>

<h3 class="center"> 6 Lessons Learned: </h3>

# Use image objects and classes instead of passing around variables in global scope.
# Use small test cases and modular designs to save time.
# If you are doing a visual project, DO visual testing.
# Vectorization can speed up @numpy@ routines by a factor of 10.
# Precomputation trades memory for speed, but is great for preloading expected user input.
# The best output comes from the best input.

<br>
{% comment %}
Failure cases
Precomputation
Demo
Timing
{% endcomment %}


fn0. "Seam Carving for Content-Aware Image Resizing":http://portal.acm.org/citation.cfm?id=1276390

fn1. While the implementation was relatively straight forward for basic functionality, speed was horrendously slow until I learned to utilize numpy vector operations such as @argmin@, @amin@, and @np.delete@

fn2. The cumulative energy paths were based from applying an edge detection filter that mapped pixel gradients to preserve high-contrast features.

fn3. Storing whether the pixel was left (red), straight (yellow), or right (green) was a recomended strategy for runtime optimization, but was more helpful for crude seam visualizations.

fn4. This problem is akin to trying to climb up a mountain that shrinks with each step and then trying to backtrack to find your path from your starting location. While you may have finished the proccess, you have lost crucial information. The picture should show some insight on how I solved this problem, but I would be happy to explain if you're curious.


<!--script src="https://gist.github.com/zzeleznick/e146e30205393b4ad9ec.js"></script-->

fn6. "Stonehenge by Day":http://www.premiumtours.co.uk/images/product/original/181_1.jpg

fn7. "Stonehenge during Lightning Strike":https://www.flickr.com/photos/kate_williams/3229244633/

fn8. "Stonehenge by Mike Parker Pearson":http://i.telegraph.co.uk/multimedia/archive/02066/Stonehenge_2066365b.jpg


fn9. "Girl with Hair Ribbon, 1965 by Roy Lichtenstein":http://www.lichtensteinfoundation.org/0278.htm



<a target="_blank" href= {{ site.github_path | escape  }}{{site.p4_logs}}> <h5 class="center"> See the logs produced for my test files </h5> </a>

<a target="_blank" href= {{ site.github_path | escape  }}{{site.p4_docs}}> <h5 class="center"> Read More about my Code </h5></a>


<comment>

### A list!

http://redcloth.org/textile/phrase-modifiers/#links

I'm really excited about "RedCloth":redcloth.
I love it so much, I think I'll name my first child "RedCloth":redcloth.
[redcloth]http://redcloth.org
 </comment>

<br>
<h5 class='center'>  - Zachary Zeleznick </h5>